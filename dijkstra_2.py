# -*- coding: utf-8 -*-
"""Dijkstra_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FjdnZ2MEQSGRhmK9hAUN8eN7SyNb8F5a
"""

from re import I
# -- coding: latin-1 --
import random
import sys  # Importa o módulo sys para controle do sistema.
import networkx as nx  # Importa a biblioteca networkx para manipulação de grafos.
import matplotlib.pyplot as plt  # Importa o matplotlib para visualização de grafos.

def dijkstra(ini, fin, grafo):  # Grafo como MA.
#Checa se a cidade de destino é a mesma do começo, se sim caminho zero
    if ini == fin:
      vazio = []
      print("Somente Vértice Inicial no caminho.")
      return vazio, 0
#Inicializa as variáveis e listas
    n = len(grafo)
    resolvido = [False] * n
    resolvido[ini] = True
    distancia = [sys.maxsize] * n
    distancia[ini] = 0
    anterior = [-1] * n
#enquanto o vértice de destino não for resolvido
    while not resolvido[fin]:
        menorDistancia = sys.maxsize #atribue um valor infinito para a menor distância
        proximo = -1 #indefine o próximo
        for i in range(n):
            if resolvido[i]:  # Só considera vértices já resolvidos
                for j in range(n):
                    peso = grafo[i][j] #Armazena o peso de cada aresta
                    if peso > 0 and not resolvido[j]: #Checa se o vértice j é adjacente e não resolvido
                        novaDistancia = distancia[i] + peso #Calcula a nova distância com o peso e a distância do vértice resolvido i
                        if novaDistancia < distancia[j]: #Se a nova distancia é menor que a distância armazenada atual, sobrescreve com a nova menor distância
                            distancia[j] = novaDistancia
                            anterior[j] = i #Guarda de qual vértice resolvido veio
                        #Escolhe o próximo vértice com menor distância não resolvido
                        if not resolvido[j] and distancia[j] < menorDistancia:
                            menorDistancia = distancia[j]
                            proximo = j #armazena o índice
        if proximo == -1: #se próximo continua indefinido então caminho inexistente
            inexistente = []
            inexistente.append(sys.maxsize)
            print("Caminho Inexistente.")
            return inexistente, sys.maxsize

        resolvido[proximo] = True #resolve o vértice com menor caminho detectado

    # Reconstrução do caminho
    caminho = [] #cria uma lista vazia
    verticeAtual = fin #define
    while verticeAtual != ini: #enquanto não for o vértice inicial
        caminho.insert(0, verticeAtual) #insere
        verticeAtual = anterior[verticeAtual] #atualiza com o anterior
        if verticeAtual == -1: #Se o anterior for -1, não há caminho
            inexistente = []
            inexistente.append(sys.maxsize)
            print("Caminho Inexistente.")
            return inexistente, sys.maxsize
    caminho.insert(0, ini) #insere o vértice inicial no início do caminho

    return caminho, distancia[fin] #retorna a lista do caminho e distância


# Função para plotar os grafos original e resultante de Dijkstra.
# 'grafo' contém a matriz de adjacências e 'caminho' contém o menor caminho.
# 'ini' e 'fin' são os vértices inicial e final respectivamente.
# 'desig' são as Designações dos vértices (nomes).
def plot_grafos(grafo, caminho, ini, fin, desig, Comp):
   G = nx.Graph()  # Grafo original.
   G_result = nx.Graph()  # Grafo resultante.

   # Adiciona as arestas do grafo original.
   for i in range(len(grafo)):  # Percorre os vértices.
      for j in range(len(grafo[i])):  # Percorre os vizinhos.
         if grafo[i][j] > 0:  # Se existe uma aresta.
            G.add_edge(i, j, weight=grafo[i][j])  # Aresta no grafo original.
            G_result.add_edge(i, j, weight=grafo[i][j])  # Aresta no grafo resultante.

   pos = nx.circular_layout(G)  # Define a disposição dos nós no gráfico.
   random.shuffle(pos)

   # Plota o grafo original.
   plt.figure(figsize=(15, 5))
   plt.subplot(1, 2, 1)  # Primeiro gráfico.

   nx.draw(G, pos, with_labels=False, node_size=0, edge_color='black')

   for node, (x, y) in pos.items():
    facecolor="white"
    if node == ini:
      facecolor="lightgreen"

    if node == fin:
      facecolor="lightsalmon"

    plt.text(x, y, desig[node],
             bbox=dict(boxstyle="round,pad=0.2", facecolor=facecolor, edgecolor="black"),
             ha='center', va='center', fontsize=10, color='black')

   nx.draw_networkx_edge_labels(G, pos, edge_labels={(u, v): d['weight'] for u, v, d
                                                    in G.edges(data=True)}, font_color='black', rotate=False)
   plt.title("Grafo Original")  # título.

   # Plota o grafo resultante.
   plt.subplot(1, 2, 2)  # Segundo gráfico.
   edge_colors = ['lightgray' if not (u in caminho and v in caminho and abs(
        caminho.index(u) - caminho.index(v)) == 1) else 'black' for u, v in G_result.edges()]  # Arestas não pertencentes ao caminho em cinza claro.

   nx.draw(G_result, pos, with_labels=False, node_size=0, edge_color=edge_colors)

   for node, (x, y) in pos.items():
      facecolor="white"
      if node == ini:
        facecolor="lightgreen"

      if node == fin:
        facecolor="lightsalmon"

      plt.text(x, y, desig[node],
              bbox=dict(boxstyle="round,pad=0.2", facecolor=facecolor, edgecolor="black"),
              ha='center', va='center', fontsize=10, color='black')


   edge_labels_result = {(u, v): d['weight'] for u, v, d in G_result.edges(data=True)}
   # Exibe os rótulos das arestas do grafo resultante com cor apropriada
   for (u, v) in edge_labels_result:
      if (u in caminho and v in caminho and abs(caminho.index(u) - caminho.index(v)) == 1):
        nx.draw_networkx_edge_labels(
            G_result,
            pos,
            edge_labels={(u, v): edge_labels_result[(u, v)]},
            font_color='black',
            rotate=False
        )

   plt.title("Grafo com Caminho Mínimo\n")  # título.
   plt.text(0.5, 1, f"Comprimento caminho: {Comp}", fontsize=10, ha='center',
           transform=plt.gca().transAxes)  # Exibe o comprimento total correto.

   plt.show()  # Exibe os dois gráficos.

# Função principal para executar o programa.
# Cria as Designações dos vértices e a matriz de adjacências.
cidades = ['Aurora','Bonito','Carmo','Douras','Estela','Felice','Gema','Herval','Ipiaú','Jaburu','Lindoa','Mundaú']  # Designações dos vértices.

# Define a matriz de adjacências com os pesos das arestas.
MA = [
   [ 0, 25, 0, 20, 33, 0, 0, 0, 0, 0, 0, 0],  # Aurora
   [ 25, 0, 32, 0, 0, 36, 0, 0, 0, 0, 0, 0],  # Bonito
   [ 0, 32, 0, 0, 0, 36, 22, 0, 0, 0, 0, 0],  # Carmo
   [ 20, 0, 0, 0, 0, 0, 42, 34, 0, 0, 0, 0],  # Douras
   [ 33, 0, 0, 0, 0, 0, 0, 30, 28, 0, 0, 0],  # Estela
   [ 0, 36, 36, 0, 0, 0, 0, 0, 40, 25, 0, 0],  # Felice
   [ 0, 0, 22, 0, 0, 0, 0, 0, 0, 50, 30, 0],   # Gema
   [ 0, 0, 0, 34, 30, 0, 0, 0, 0, 45, 45, 55],  # Herval
   [ 0, 0, 0, 0, 28, 40, 0, 0, 0, 0, 40, 60],  # Ipiaú
   [ 0, 0, 0, 0, 0, 25, 50, 45, 0, 0, 0, 0],  # Jaburu
   [ 0, 0, 0, 0, 0, 0, 30, 45, 40, 0, 0, 0],  # Lindoa
   [ 0, 0, 0, 0, 0, 0, 0, 55, 60, 0, 0, 0],  # Mundaú
   ]  # Matriz de adjacências que representa o grafo.

print(" 1 - Aurora, 2 - Bonito, 3 - Carmo, 4 - Douras, 5 - Estela, 6 - Felice, 7 - Gema, 8 - Herval, 9 - Ipiaú, 10 - Jaburu, 11 - Lindoa, 12 - Mundaú")

try:
  orig = int(input("Escolha uma cidade de origem (1 a 12): "))
except ValueError:
  print("\nErro: Entrada inválida! Digite um número inteiro entre 1 e 12.\n") # Encerra o programa imediatamente
  exit()
if orig > 12 or orig < 1:
  print("\nErro: Cidade não encontrada! Digite um número entre 1 e 12.\n") # Encerra o programa imediatamente
  exit()
else:
  orig -= 1
print("Origem selecionada: " + cidades[orig])

try:
  destf = int(input("Escolha uma cidade de destino (1 a 12): "))
except ValueError:
  print("\nErro: Entrada inválida! Digite um número inteiro entre 1 e 12.\n") # Encerra o programa imediatamente
  exit()
if destf > 12 or destf < 1:
  print("\nErro: Cidade não encontrada! Digite um nome válido.\n")  # Encerra o programa imediatamente
  exit()
else:
  destf -= 1
print("Destino selecionado: " + cidades[destf])

# Executa o algoritmo de Dijkstra e exibe o menor caminho e o seu custo.
caminho, Comp = dijkstra(orig, destf, MA)  # Executa Dijkstra.
print("Menor caminho de %s até %s: %-13s\nComprimento: %3d" %  # Exibe o resultado.
     (cidades[orig], cidades[destf], " > ".join(cidades[v] for v in caminho), Comp))
CompTot = Comp

# Exibe outros caminhos para diferentes destinos a partir do vértice inicial.
print("\n------------------------------")
print("Outros destinos")
print("------------------------------")
print("Destino: Caminho (Comprimento)")
print("------------------------------")

# Laço para encontrar e exibir o menor caminho para todos os vértices.
for dest in range(len(MA)):  # Percorre todos os destinos.
   if orig != dest and dest != destf:  # Exclui o vértice inicial e final.
      Path, Comp = dijkstra(orig, dest, MA)  # Calcula o caminho.
      print(" " + cidades[dest], end="     ")
      print("%-13s ( %3d )" % (" > ".join(cidades[v] for v in Path), Comp))
      # Acima: exibe (associa cidade ao índice).

# Plota os grafos original e resultante com o comprimento total.
plot_grafos(MA, caminho, orig, destf, cidades, CompTot)  # Chama a Função para plotar.
